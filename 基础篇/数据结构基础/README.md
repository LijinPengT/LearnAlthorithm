# 二、线性表

## 2.1 线性结构

1. 开始结点，终止结点，内部结点
2. 前驱后继，直接前驱，直接后继，
3. 反对称性和传递性
4. 均匀性， 有序性
5. 简单的线性结构：线性表，栈，队列，散列表，高级的线性结构：广义表，多维数组，文件
6. 直接访问型，顺序访问型，目录索引型
7. 按操作：线性表，栈，队列
8. 逻辑结构，存储结构，线性表运算
9. 先定位，再运算
10. 存储结构：顺序表；链表，单链表，双链表，循环链表；
11. 运算：栈：深搜；队列：宽搜

## 2.2 顺序表

1. 主要特性:
    + 元素类型相同
    + 元素顺序地存储在连续存储空间中，每一个元素有唯一的索引值
    + 使用常数作为向量长度

2. 元素地址计算

    > Loc(ki) = Loc(k0) + c x i, c=sizeof(ELEM) ->sizeof()计算的是存储的字节长度

3. 读写方便，通过下标即可指定位置
    + 只要确定了首地址，线性表中任意数据元素都可以随机存取

4. 顺序表类定义
    ```
    class arrList:public List<T> {                  //顺序表，向量
        private:                                    //线性表的取值类型和取值空间
          T *aList;                                 //私有变量，存储顺序表的实例
          int maxSize;                              //私有变量，顺序表实例的最大长度
          int curLen;                               //私有变量，顺序表实例的当前长度
          int position;                             //私有变量，当前处理位置
        public:
          arrList(const int size) {                 //创建新表，设置表实例的最大长度
            maxSize = size; aList = new T[maxSize];
                curLen = position = 0;
          }
          ~arrList() {                              //析构函数，用于消除该表实例
              delete [] aList;
          }
          void clear() {                            //将顺序表存储的内容清楚，成为空表
              delete [] aList; curLen = position = 0;
                aList = new T[maxSize];
          }
          int length();                             //返回当前实际长度
          bool append(const T value);               //在表尾添加元素
          bool insert(const int p, const T value);  //插入元素
          bool delete(const int p);                 //删除位置p上的元素
          bool setValue(const int p, const T value);//设元素值
          bool getValue(const int p, T& value);     //返回元素
          bool getPos(int &p, const T value);       //查找元素
    }
    ```

## 2.3 链表

1. 存储结点组成：数据域+指针域
2. 单链表：带头结点的单链表
3. 双链表，增加前驱指针
4. 循环链表，首尾相连，不增加额外开销，对操作带来方便
5. 特殊点处理
    + 头指针处理
    + 表尾结点的指针域保持为NULL
    + 循环链表尾结点的指针回指针头结点
6. 链表处理
    + 空链表的特殊处理
    + 插入或删除结点时指针勾链的顺序
    + 指针移动的正确性
        + 插入
        + 查找或遍历
7. 如何判断单链表中是否有回路？
    + 快慢指针法，追赶问题，赶上回路，否则无回路

## 2.4 线性表实现方法的比较

1. 顺序表的主要优点：
    + 没有使用指针，不用化肥额外开销
    + 线性表元素的读访问非常简洁便利
    + 是存储静态数据的不二选择
    + 插入，删除O(n), 查找O(1)
    + 预先申请固定长度的空间
    + 存储效率高，如果数组元素很满，则没有存储性开销

2. 链表的主要优点
    + 无需事先了解线性表的长度
    + 允许线性表的长度动态变化
    + 能够适应经常插入删除内部元素的情况
    + 存储动态变化数据的良方
    + 插入、删除时间代价为O(1), 但找到第i个元素运算时间代价为O(n)
    + 存储利用指针，动态地按照需要为表中的新的元素分配存储空间
    + 每个元素都有结构性存储开销

3. 练习：
    + 一维数组的最大子数组之和
    + 一维循环数组的最大子数组之和
    + 二位数组的最大子数组之和
    + 二维循环数组的最大子数组之和
    + 莫比乌斯环数组的最大子数组之和
